# Test powershell script showing off a bunch of different powershell language features generated by ChatGPT
# Use this to see if the features in powershell-ts-mode are working correctly

# Define a simple function
function Get-MultipliedNumber {
    param (
        [int]$Number,
        [int]$Multiplier = 2
    );

    $Number * $Multiplier
}

# Use variables and basic arithmetic
$number = 5
$multipliedNumber = Get-MultipliedNumber -Number $number -Multiplier 3
Write-Host "Multiplied Number: $multipliedNumber"

# Working with arrays
$array = 1..10
$filteredArray = $array | Where-Object { $_ % 2 -eq 0 }
Write-Host "Even Numbers: $filteredArray"

# Conditional logic
if ($multipliedNumber -gt 10) {
    Write-Host "Greater than 10"
} else {
    Write-Host "10 or less"
}

# Looping through items
foreach ($item in $filteredArray) {
    Write-Host "Processing item: $item"
}

# Creating and using a custom object
$person = [PSCustomObject]@{
    FirstName = 'John'
    LastName = 'Doe'
    Age = 30
}
Write-Host "Person's Full Name: $($person.FirstName) $($person.LastName)"

# Error handling with Try/Catch
try {
    $content = Get-Content -Path "C:\nonexistentfile.txt"
} catch {
    Write-Host "Error: $_"
}

# Interacting with the file system
$desktopPath = [System.Environment]::GetFolderPath("Desktop")
$newFilePath = Join-Path -Path $desktopPath -ChildPath "testfile.txt"
"Hello, PowerShell!" | Out-File -FilePath $newFilePath
Write-Host "Created a new file at $newFilePath"

# Advanced feature: PowerShell workflows for parallel processing
workflow Test-ParallelProcessing {
    $computers = 'Computer1', 'Computer2', 'Computer3'
    foreach -parallel ($computer in $computers) {
        # This example just echoes the computer name
        # In a real scenario, you might perform actions like checking connectivity, services, etc.
        Write-Output "Processing $computer"
    }
}

# Invoke the workflow
Test-ParallelProcessing

# Working with PS Jobs for asynchronous tasks
$job = Start-Job -ScriptBlock {
    1..10 | ForEach-Object {
        Start-Sleep -Seconds 1
        $_
    }
}

# Wait for the job to complete and receive job results
Wait-Job $job
$results = Receive-Job $job
Write-Host "Asynchronous job results: $results"

# Remove the job
Remove-Job $job

# Working with Modules and Importing
# Note: This requires the `PSReadLine` module to be installed on your system.
Import-Module PSReadLine
Get-Command -Module PSReadLine

# Using .NET classes and methods
$dateTime = [System.DateTime]::Now
Write-Host "Current Date and Time: $dateTime"

# Creating and manipulating a Hashtable
$hashtable = @{
    Name = 'John Doe'
    Age = 30
    City = 'New York'
}
$hashtable['Country'] = 'USA'
Write-Host "Hashtable values: $($hashtable.GetEnumerator() | Out-String)"

# Advanced Function with CmdletBinding and Parameter Validation
function Get-AdvancedGreeting {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string]$Name,

        [ValidateSet("Morning", "Afternoon", "Evening")]
        [string]$TimeOfDay
    )

    "Good $TimeOfDay, $Name!"
}

# PowerShell Profile Example (This line would typically go in a PowerShell profile file)
# Write-Host "Welcome to PowerShell!"

# PowerShell Remoting
Invoke-Command -ComputerName RemoteServer -ScriptBlock { Get-Process } -Credential (Get-Credential)

# Regular Expressions
if ("PowerShell" -match "shell$") {
    "Matches pattern"
}

# XML Parsing
[xml]$xmlContent = "<root><element>Value</element></root>"
$xmlContent.root.element

# JSON Parsing
$jsonString = '{"Name": "John", "Age": 30}'
$jsonObject = $jsonString | ConvertFrom-Json
$jsonObject.Name

# PowerShell Classes
class Person {
    [string]$Name
    [int]$Age

    Person([string]$name, [int]$age) {
        $this.Name = $name
        $this.Age = $age
    }

    [string] Greet() {
        return "Hello, my name is $($this.Name) and I am $($this.Age) years old."
    }
}

# DSC Configuration
Configuration ExampleConfiguration {
    Node "localhost" {
        File ExampleFile {
            DestinationPath = "C:\example.txt"
            Contents = "Hello, DSC!"
        }
    }
}

# PSProviders and PSDrives
Set-Location HKCU:
Get-ChildItem

# Transactions
Start-Transaction
New-Item -Path "HKCU:\Software\ExampleKey" -ItemType Directory -UseTransaction
Undo-Transaction

# Error Handling Enhancements
try {
    Get-Content NonExistentFile.txt -ErrorAction Stop
} catch {
    Write-Host "Caught an error: $_"
}

# Event Handling
$timer = New-Object timers.timer
$timer.Interval = 1000 # One second
Register-ObjectEvent -InputObject $timer -EventName Elapsed -Action { Write-Host "Timer ticked!" }
$timer.Start()

# Using Workflows for Parallel Processing
workflow Get-ParallelProcess {
    parallel {
        Get-Process powershell
        Get-Service WinRM
    }
}

# Security Features: Secure String
$secureString = ConvertTo-SecureString "PlainTextPassword" -AsPlainText -Force
$secureString

# Debugging Script Example (Place a breakpoint on the Write-Host line in an IDE)
Write-Host "Debug this line"

# Using Web Requests
$response = Invoke-WebRequest -Uri "https://api.github.com/users/octocat"
$response.Content

# Pipeline Enhancements
Get-Process | Where-Object {$_.WorkingSet -gt 100MB} | Sort-Object WorkingSet -Descending | Select-Object -First 5

# Writing and Importing a Module
# Module file content: function Get-ModuleGreeting { "Hello from the module!" }
Import-Module ./MyCustomModule.psm1
Get-ModuleGreeting

# Custom Tab Completion
Register-ArgumentCompleter -CommandName 'Get-AdvancedGreeting' -ParameterName 'TimeOfDay' -ScriptBlock {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameters)
    'Morning', 'Afternoon', 'Evening' | Where-Object { $_ -like "$wordToComplete*" }
}

# Scheduled Jobs
$trigger = New-JobTrigger -At 3:00pm -Daily
Register-ScheduledJob -Name "DailyProcessCheck" -ScriptBlock { Get-Process } -Trigger $trigger

# Cross-Platform Feature Example (Using PowerShell Core)
$os = [System.Runtime.InteropServices.RuntimeInformation]::OSDescription
Write-Host "Running on: $os"

# Using Splatting with Parameters
$params = @{
    Path = 'C:\'
    Filter = '*.txt'
    Recurse = $true
}
Get-ChildItem @params

# Creating Hash Tables and Working with Them
$hashTable = @{
    Name = 'Jane Doe'
    Occupation = 'Software Developer'
    Age = 28
}
$hashTable['Location'] = 'New York'
foreach ($key in $hashTable.Keys) {
    "$key : $($hashTable[$key])"
}

# Custom Formatting with Format Operators
$name = 'John'
$age = 34
Write-Host ("My name is {0} and I am {1} years old." -f $name, $age)

# Using Here-Strings
$multiLineString = @"
This is a multi-line string.
You can write as many lines as you want.
This is the third line.
"@

Write-Host $multiLineString

# Background Jobs for Asynchronous Operations
$job = Start-Job -ScriptBlock {
    Get-Process | Where-Object { $_.CPU -gt 100 }
}
# Wait for the job to complete
Wait-Job $job
# Get job results
$results = Receive-Job $job
$results | Format-Table Name, CPU
# Clean up the job
Remove-Job $job

# Accessing and Manipulating Environment Variables
$env:MY_CUSTOM_VARIABLE = "PowerShell Rocks"
$myVar = $env:MY_CUSTOM_VARIABLE
Write-Host "Environment Variable Value: $myVar"

# Creating and Invoking Script Blocks
$scriptBlock = {
    param($message)
    Write-Host "Message from script block: $message"
}
& $scriptBlock -message "Hello, PowerShell Script Block!"

# Advanced Error Handling with $ErrorActionPreference and Trap
function Test-ErrorHandling {
    $ErrorActionPreference = 'Stop'
    trap {
        Write-Host "Caught an error: $_"
        continue
    }
    # This command will fail and trigger the trap
    Get-ChildItem NonExistentFile.txt
}
Test-ErrorHandling

# Using Tee-Object to Send Output to Multiple Places
Get-Process | Tee-Object -FilePath "./processes.txt" | Format-Table Name, Id

# Working with Dates and Times
$currentDate = Get-Date
$futureDate = $currentDate.AddDays(10)
Write-Host "Current Date: $currentDate, Future Date: $futureDate"

# Using PowerShell to Access SQL Databases
# Note: Requires SQLServer module or appropriate data access technology
Invoke-Sqlcmd -Query "SELECT TOP 10 * FROM MyTable" -Database "MyDatabase" -ServerInstance "MyServer"

# Working with REST APIs using Invoke-RestMethod
$response = Invoke-RestMethod -Uri 'https://api.example.com/data' -Method Get -Headers @{ 'Authorization' = 'Bearer YOUR_TOKEN' }
$response.data

# Multithreading with Runspaces
$runspacePool = [runspacefactory]::CreateRunspacePool(1, 5)
$runspacePool.Open()
$runspaces = @()
for ($i = 0; $i -lt 10; $i++) {
    $powershell = [powershell]::Create().AddScript({
        Start-Sleep -Seconds (Get-Random -Minimum 1 -Maximum 5)
        return Get-Random -Minimum 1 -Maximum 100
    })
    $powershell.RunspacePool = $runspacePool
    $runspaces += [PSCustomObject]@{
        Pipe = $powershell
        Handle = $powershell.BeginInvoke()
    }
}
foreach ($runspace in $runspaces) {
    $result = $runspace.Pipe.EndInvoke($runspace.Handle)
    $runspace.Pipe.Dispose()
    Write-Host "Result: $result"
}

$runspacePool.Close()


function Ensure-ModuleInstalled($module) {
    # install psGet if Get-Module not exist
    if (!$script:installModule)
    {
        if (!(Get-Command 'Install-Module' -ErrorAction SilentlyContinue))
        {
            (new-object Net.WebClient).DownloadString("http://psget.net/GetPsGet.ps1") | Invoke-Expression
        }
    }

    if (!(Get-Module -name $module))
    {
        if (!(Get-Module -list $module))
        {
            if ($script:installModule.Parameters.ContainsKey('Scope'))
            {
                Install-Module $module -Scope CurrentUser -Force
            }
            else
            {
                Install-Module $module -Force
            }
        }

        Import-Module $module
        Test-a;
    }

    Test-A;
    Test-B;
}

cd TestA;
Ensure-ModuleInstalled `
    -module "Test" `
    -module "t";

{
    Get-A | `
        Test-B | `
        Test-C;
}

$a = New-WinUserLanguageList "zh-cn"
$a.Add("en-us", "ha-au")

Set-WinUserLanguageList $a -Force

$long_name = 12;

# write a function to login into azure cloud
function Login-AzureCloud()
{
    $azureCloud = "AzureCloud";
    $azureCloudId = "Microsoft Azure";
    $azureCloudTenantId = "";

    $azureCloudAccount = Get-AzureRmContext | Select-Object -ExpandProperty Account;
    if ($azureCloudAccount -eq $null)
    {
        $azureCloudAccount = New-AzureRmAccount -Environment $azureCloud -TenantId $azureCloudTenantId;
    }

    $azureCloudAccount | Select-Object -ExpandProperty Id;
}

{
    function test ([string] $a, [string] $b)
    {
        param ([string]$name,
               [version]$version,
               [bool]$prerelease = $true,
               [bool]$ondemand = $false);
        $test =
            {
                $a = 12;
            };
        Test-A;
        Test-B;
    }
}

{
    if (!$script:installModule -and
        ($test -eq 2) -or
        ($test -eq 3 -and
         $test -eq 3))
    {
    }

    if (!(Get-Command 'Install-Module' -ErrorAction SilentlyContinue))
    {
        (new-object Net.WebClient).DownloadString("http://psget.net/GetPsGet.ps1") | Invoke-Expression

    }
    elseif ($test -eq 3 -and $test -ne 4)
    {
        asd;
    }
    else
    {
        asd;
    }

}

{
    while ($test -eq 2 -and $test -ne 3)
    {
        $test = 3;
    }

    do
    {
        $test = 3;
    }
    while ($test -eq 2 -and
           $true -and $false 
    );
}

{

    for ($i = 0; $i -lt 10 -and $true; $i++)
    {
        $test = 3;
    }

    foreach ($i in 1..10)
    {
        $test = 3;
    }

    switch ($test -and $true)
    {
        1
        {
            $test = 3;
        }
        2
        {
            $test = 3;
        }

        default {
            $test = 3;
        }
    }

    try
    {
        $test = 3;
    }
    catch
    {
        $test = 3;
    }
    finally
    {
        $test = 3;
    }

    trap
    {
        $test = 3;
    }
}

{
    class
        Device
    {
        [string] $Brand = 12;
        [void]
            Test()
        {
        }
    }
}

{
    $a = $b =
        @(
            12,
            {$b, $s},
            4
        );
}

{

    $b = @{
        $azureCloud = 112;
        $ads        = 12;
        $ads        = 12;
    }
}

function ensure_params ([GitCommand] $command) {
    if (($command.Type -eq [GitCommandType]::Builtin) -and ($command.Params.Count -eq 0)) {
        git $command.Command.Display -h 2>&1 `
            | Select-String -AllMatches -Pattern '(?<=(^ +|, *|\[|\|))-{1,2}[^ ,|\[\]]+'  `
            | ForEach-Object { $_.Matches.Value; } `
            | Select-Object -Unique `
            | ForEach-Object { [void] $command.Params.Add([GitCompletionResult]::new($_, 'Param')); };
    }
}
